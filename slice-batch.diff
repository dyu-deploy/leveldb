diff --git a/db/db_impl.cc b/db/db_impl.cc
index 60f4e66..2f23c5c 100644
--- a/db/db_impl.cc
+++ b/db/db_impl.cc
@@ -1263,6 +1263,80 @@ Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {
   return status;
 }
 
+Status DBImpl::WriteUpdates(const WriteOptions& options, Slice updates, std::function<void(const Slice&, const Slice&)> handler) {
+  /*Writer w(&mutex_);
+  w.batch = my_batch; // TODO
+  w.sync = options.sync;
+  w.done = false;
+
+  MutexLock l(&mutex_);
+  writers_.push_back(&w);
+  while (!w.done && &w != writers_.front()) {
+    w.cv.Wait();
+  }
+  if (w.done) {
+    return w.status;
+  }
+
+  // May temporarily unlock and wait.
+  Status status = MakeRoomForWrite(false);
+  uint64_t last_sequence = versions_->LastSequence();
+  Writer* last_writer = &w;
+  if (status.ok()) {  // NULL batch is for compactions
+    WriteBatch* updates = BuildBatchGroup(&last_writer);
+    WriteBatchInternal::SetSequence(updates, last_sequence + 1);
+    last_sequence += WriteBatchInternal::Count(updates);
+
+    // Add to log and apply to memtable.  We can release the lock
+    // during this phase since &w is currently responsible for logging
+    // and protects against concurrent loggers and concurrent writes
+    // into mem_.
+    {
+      mutex_.Unlock();
+      status = log_->AddRecord(WriteBatchInternal::Contents(updates));
+      bool sync_error = false;
+      if (status.ok() && options.sync) {
+        status = logfile_->Sync();
+        if (!status.ok()) {
+          sync_error = true;
+        }
+      }
+      if (status.ok()) {
+        status = WriteBatchInternal::InsertInto(updates, mem_);
+      }
+      mutex_.Lock();
+      if (sync_error) {
+        // The state of the log file is indeterminate: the log record we
+        // just added may or may not show up when the DB is re-opened.
+        // So we force the DB into a mode where all future writes fail.
+        RecordBackgroundError(status);
+      }
+    }
+    if (updates == tmp_batch_) tmp_batch_->Clear();
+
+    versions_->SetLastSequence(last_sequence);
+  }
+
+  while (true) {
+    Writer* ready = writers_.front();
+    writers_.pop_front();
+    if (ready != &w) {
+      ready->status = status;
+      ready->done = true;
+      ready->cv.Signal();
+    }
+    if (ready == last_writer) break;
+  }
+
+  // Notify new head of write queue
+  if (!writers_.empty()) {
+    writers_.front()->cv.Signal();
+  }
+
+  return status;*/
+  return Status::OK();
+}
+
 // REQUIRES: Writer list must be non-empty
 // REQUIRES: First writer must have a non-NULL batch
 WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) {
diff --git a/db/db_impl.h b/db/db_impl.h
index 8ff323e..4da1c76 100644
--- a/db/db_impl.h
+++ b/db/db_impl.h
@@ -32,6 +32,7 @@ class DBImpl : public DB {
   virtual Status Put(const WriteOptions&, const Slice& key, const Slice& value);
   virtual Status Delete(const WriteOptions&, const Slice& key);
   virtual Status Write(const WriteOptions& options, WriteBatch* updates);
+  virtual Status WriteUpdates(const WriteOptions& options, Slice updates, std::function<void(const Slice&, const Slice&)> handler);
   virtual Status Get(const ReadOptions& options,
                      const Slice& key,
                      std::string* value);
diff --git a/db/write_batch.cc b/db/write_batch.cc
index 33f4a42..fca01f3 100644
--- a/db/write_batch.cc
+++ b/db/write_batch.cc
@@ -39,8 +39,7 @@ void WriteBatch::Clear() {
   rep_.resize(kHeader);
 }
 
-Status WriteBatch::Iterate(Handler* handler) const {
-  Slice input(rep_);
+static Status IterateUpdates(WriteBatch::Handler* handler, Slice input, int count) {
   if (input.size() < kHeader) {
     return Status::Corruption("malformed WriteBatch (too small)");
   }
@@ -72,13 +71,17 @@ Status WriteBatch::Iterate(Handler* handler) const {
         return Status::Corruption("unknown WriteBatch tag");
     }
   }
-  if (found != WriteBatchInternal::Count(this)) {
+  if (found != count) {
     return Status::Corruption("WriteBatch has wrong count");
   } else {
     return Status::OK();
   }
 }
 
+Status WriteBatch::Iterate(Handler* handler) const {
+  return IterateUpdates(handler, Slice(rep_), WriteBatchInternal::Count(this));
+}
+
 int WriteBatchInternal::Count(const WriteBatch* b) {
   return DecodeFixed32(b->rep_.data() + 8);
 }
@@ -109,6 +112,7 @@ void WriteBatch::Delete(const Slice& key) {
 }
 
 namespace {
+
 class MemTableInserter : public WriteBatch::Handler {
  public:
   SequenceNumber sequence_;
@@ -123,6 +127,28 @@ class MemTableInserter : public WriteBatch::Handler {
     sequence_++;
   }
 };
+
+class DelegateFnHandler : public WriteBatch::Handler {
+ public:
+  DelegateFnHandler(std::function<void(const Slice&, const Slice&)> handler)
+    : handler_(handler),
+      inserter_() {
+  }
+  std::function<void(const Slice&, const Slice&)> handler_;
+  MemTableInserter inserter_;
+  
+  virtual void Put(const Slice& key, const Slice& value) {
+    inserter_.Put(key, value);
+    handler_(key, value);
+  }
+  virtual void Delete(const Slice& key) {
+    inserter_.Delete(key);
+  }
+ private:
+  DelegateFnHandler(const DelegateFnHandler&);
+  DelegateFnHandler& operator = (const DelegateFnHandler&);
+};
+
 }  // namespace
 
 Status WriteBatchInternal::InsertInto(const WriteBatch* b,
@@ -133,6 +159,22 @@ Status WriteBatchInternal::InsertInto(const WriteBatch* b,
   return b->Iterate(&inserter);
 }
 
+Status WriteBatchInternal::InsertUpdatesInto(const Slice updates,
+                                      MemTable* memtable) {
+  MemTableInserter inserter;
+  inserter.sequence_ = SequenceNumber(DecodeFixed64(updates.data_));
+  inserter.mem_ = memtable;
+  return IterateUpdates(&inserter, updates, DecodeFixed32(updates.data_ + 8));
+}
+
+Status WriteBatchInternal::InsertUpdatesWithHandlerInto(const Slice updates,
+                                      MemTable* memtable, std::function<void(const Slice&, const Slice&)> handler) {
+  DelegateFnHandler dh(handler);
+  dh.inserter_.sequence_ = SequenceNumber(DecodeFixed64(updates.data_));
+  dh.inserter_.mem_ = memtable;
+  return IterateUpdates(&dh, updates, DecodeFixed32(updates.data_ + 8));
+}
+
 void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {
   assert(contents.size() >= kHeader);
   b->rep_.assign(contents.data(), contents.size());
diff --git a/db/write_batch_internal.h b/db/write_batch_internal.h
index 9448ef7..90e44ec 100644
--- a/db/write_batch_internal.h
+++ b/db/write_batch_internal.h
@@ -40,6 +40,10 @@ class WriteBatchInternal {
   static void SetContents(WriteBatch* batch, const Slice& contents);
 
   static Status InsertInto(const WriteBatch* batch, MemTable* memtable);
+  
+  static Status InsertUpdatesInto(const Slice updates, MemTable* memtable);
+  
+  static Status InsertUpdatesWithHandlerInto(const Slice updates, MemTable* memtable, std::function<void(const Slice&, const Slice&)> handler);
 
   static void Append(WriteBatch* dst, const WriteBatch* src);
 };
diff --git a/include/leveldb/db.h b/include/leveldb/db.h
index 9752cba..f08c181 100644
--- a/include/leveldb/db.h
+++ b/include/leveldb/db.h
@@ -7,6 +7,7 @@
 
 #include <stdint.h>
 #include <stdio.h>
+#include <functional>
 #include "leveldb/iterator.h"
 #include "leveldb/options.h"
 
@@ -72,6 +73,10 @@ class DB {
   // Returns OK on success, non-OK on failure.
   // Note: consider setting options.sync = true.
   virtual Status Write(const WriteOptions& options, WriteBatch* updates) = 0;
+  
+  // Same as above (the data that the batch holds is basically the slice passed here)
+  // plus an optional callback function for the entries being inserted/updated.
+  virtual Status WriteUpdates(const WriteOptions& options, Slice updates, std::function<void(const Slice&, const Slice&)> handler) = 0;
 
   // If the database contains an entry for "key" store the
   // corresponding value in *value and return OK.
